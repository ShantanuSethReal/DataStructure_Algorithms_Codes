Customer Class{
    Customer object- id,name,email
}

Database Class{
    The Statement interface provides methods to execute queries with the database. The statement interface is a factory of ResultSet i.e. it provides factory method to get the object of ResultSet.The object used for executing a static SQL statement and returning the results it produces.
    public interface Connection extends Wrapper, AutoCloseable
    A connection (session) with a specific database. SQL statements are executed and results are returned within the context of a connection.
    A Connection object's database is able to provide information describing its tables, its supported SQL grammar, its stored procedures, the capabilities of this connection, and so on. This information is obtained with the getMetaData method
    Attempts to establish a connection to the given database URL. The DriverManager attempts to select an appropriate driver from the set of registered JDBC drivers.Driver Manager- Creates a Statement object for sending SQL statements to the database. SQL statements without parameters are normally executed using.
    Result Set-A table of data representing a database result set, which is usually generated by executing a statement that queries the database.
}

Product Class{
    public class SimpleIntegerProperty extends IntegerPropertyBase
    This class provides a full implementation of a Property wrapping a int value.
    In JavaFX, collections are defined by the package known as javafx.collections that contains different interfaces such as ObservableList, ListChangeListener , ObservableMap , MapChangeListener, and classes such as FXCollections, ListChangeListener.Change, MapChangeListener.Change et
}

ProductList{
    The cell value factory needs to be set to specify how to populate all cells within a single TableColumn. A cell value factory is a Callback that provides a TableColumn.CellDataFeatures instance, and expects an ObservableValue to be returned. The returned ObservableValue instance will be observed internally to allow for immediate updates to the value to be reflected on screen.A common approach is to want to populate cells in a TableColumn using a single value from a Java bean. To support this common scenario, there is the PropertyValueFactory class
    Firstly, a TableView instance needs to be defined, as such:

    TableView<Person> table = new TableView<Person>();
    With the basic table defined, we next focus on the data model. As mentioned, for this example, we'll be using a ObservableList. We can immediately set such a list directly in to the TableView, as such:

    ObservableList<Person> teamMembers = getTeamMembers();
    table.setItems(teamMembers);
    With the items set as such, TableView will automatically update whenever the teamMembers list changes. If the items list is available before the TableView is instantiated, it is possible to pass it directly into the constructor.

    At this point we now have a TableView hooked up to observe the teamMembers observableList. The missing ingredient now is the means of splitting out the data contained within the model and representing it in one or more TableColumn instances. To create a two-column TableView to show the firstName and lastName properties, we extend the last code sample as follows
}

Order{

}

Login{

}

Ecommerce{
    A scene represents the physical contents of a JavaFX application. It contains all the contents of a scene graph. The class Scene of the package javafx. scene represents the scene object. JavaFX Stage, javafx.stage.Stage, represents a window in a JavaFX desktop application. Inside a JavaFX Stage you can insert a JavaFX Scene which represents the content displayed inside a window - inside a Stage.
}

